#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
#include <stdlib.h>
#include <time.h>
#include <definition.h>
#include <SC.h>

using namespace std;

int main(int argc,char** argv){
    SC sc;
    srand(time(NULL));
    cout<<"program in"<<endl;
    bool all_one[bit_len];
    bool all_zero[bit_len];
    bool* stream1;
    bool* stream2;
    bool* stream3;
    // for(unsigned i = 0; i < 10000; i++){
    //     double r1 = (double)rand() / (RAND_MAX + 1.0);
    //     stream1 = sc.bit_gen(r1);
    //     double r2 = (double)rand() / (RAND_MAX + 1.0);
    //     stream2 = sc.bit_gen(r2);
    //     stream3 = sc.MUX(stream2,stream1);
    //     cout<<sc.print(stream3) - (r1 + r2) / 2.0 <<endl;
    // }
    // ESL w,x,y,z,out1,out2,a;
    // double answer1 = 0,answer2 = 0;
    // x = sc.number_gen(0.3); //error here!!!
    // y = sc.number_gen(0.6);
    // z = sc.number_gen(0.6);
    // w = sc.number_gen(3);
    // cout<<"numnber generated"<<endl;
    // out1 = sc.APC(x,y);
    // out2 = sc.XNOR(w,z);
    // a = sc.XNOR(out1,out2);

    // cout<<"out1 = "<<sc.print(out1)<<endl;

 double weight_1[15][4] = {{-0.07908643782138824,0.9973660707473755,-0.978460967540741,-0.9846790432929993},
{-0.1007763221859932,0.9835515022277832,-0.9768840074539185,-0.9818387031555176},
{0.6234217286109924,-0.7810666561126709,0.9994845986366272,0.9892273545265198},
{0.5345491170883179,0.7543918490409851,-0.9953688383102417,-0.9926974177360535},
{-0.7034684419631958,0.9985064268112183,-0.984462320804596,-0.9876894950866699},
{-0.7834042310714722,0.9977473020553589,-0.9906774759292603,-0.984091579914093},
{0.29448118805885315,-0.9887220859527588,0.995277464389801,0.9807356595993042},
{0.19631007313728333,-0.9985790848731995,0.9865773916244507,0.9974721670150757},
{-0.9738588929176331,0.9789074063301086,-0.9884924292564392,-0.9754586219787598},
{0.9904768466949463,0.23786048591136932,-0.9918976426124573,-0.9986149072647095},
{0.3760274350643158,-1.3363944292068481,1.1614145040512085,1.9140492677688599},
{-0.8982527852058411,-0.1474817842245102,1.6031789779663086,2.5539369583129883},
{0.20365400612354279,-1.6132123470306396,2.6763079166412354,3.1139614582061768},
{0.39640671014785767,-2.403094530105591,2.5144670009613037,2.3501076698303223},
{0.42614173889160156,-1.0412988662719727,1.9456969499588013,2.5371458530426025}};
double bias_1[15] = {0.05988133326172829,0.8300730586051941,-0.9653012752532959,1.2293974161148071,1.1555607318878174,0.31279462575912476,-0.4781709611415863,0.017671426758170128,0.5851829648017883,1.145073413848877,-0.8173034191131592,-0.752415657043457,0.001721149543300271,-0.9549801349639893,0.14923426508903503};
double weight_2[3][15] = {{0.9993751049041748,0.9997856020927429,-0.9927250742912292,0.9985874891281128,0.992669939994812,0.9997040033340454,-0.8994466066360474,-0.8975275754928589,0.9845537543296814,0.8108261823654175,-1.1890463829040527,-0.9467137455940247,-1.8369648456573486,-1.674760103225708,-1.1571017503738403},
{-0.07919186353683472,0.4415972828865051,-0.2552824020385742,0.9955750703811646,0.040952540934085846,-0.6042303442955017,0.15474677085876465,0.2706112861633301,-0.6264472007751465,0.9854909181594849,-0.34918689727783203,-1.8210647106170654,-0.06081065535545349,-0.02443634532392025,0.15196341276168823},
{-0.9737448692321777,-0.9840054512023926,0.9793273210525513,-0.9912576079368591,-0.9913719892501831,-0.9918672442436218,0.9921668171882629,0.8422000408172607,-0.991192638874054,-0.9978939890861511,1.6573805809020996,1.7370538711547852,2.246500015258789,2.2573986053466797,1.5747003555297852}};
double bias_2[3] = {0.32867899537086487,0.3085203468799591,-0.3535800278186798};
    double x_test[30][4] = {{6.1000, 2.8000, 4.7000, 1.2000},
        {5.7000, 3.8000, 1.7000, 0.3000},
        {7.7000, 2.6000, 6.9000, 2.3000},
        {6.0000, 2.9000, 4.5000, 1.5000},
        {6.8000, 2.8000, 4.8000, 1.4000},
        {5.4000, 3.4000, 1.5000, 0.4000},
        {5.6000, 2.9000, 3.6000, 1.3000},
        {6.9000, 3.1000, 5.1000, 2.3000},
        {6.2000, 2.2000, 4.5000, 1.5000},
        {5.8000, 2.7000, 3.9000, 1.2000},
        {6.5000, 3.2000, 5.1000, 2.0000},
        {4.8000, 3.0000, 1.4000, 0.1000},
        {5.5000, 3.5000, 1.3000, 0.2000},
        {4.9000, 3.1000, 1.5000, 0.1000},
        {5.1000, 3.8000, 1.5000, 0.3000},
        {6.3000, 3.3000, 4.7000, 1.6000},
        {6.5000, 3.0000, 5.8000, 2.2000},
        {5.6000, 2.5000, 3.9000, 1.1000},
        {5.7000, 2.8000, 4.5000, 1.3000},
        {6.4000, 2.8000, 5.6000, 2.2000},
        {4.7000, 3.2000, 1.6000, 0.2000},
        {6.1000, 3.0000, 4.9000, 1.8000},
        {5.0000, 3.4000, 1.6000, 0.4000},
        {6.4000, 2.8000, 5.6000, 2.1000},
        {7.9000, 3.8000, 6.4000, 2.0000},
        {6.7000, 3.0000, 5.2000, 2.3000},
        {6.7000, 2.5000, 5.8000, 1.8000},
        {6.8000, 3.2000, 5.9000, 2.3000},
        {4.8000, 3.0000, 1.4000, 0.3000},
        {4.8000, 3.1000, 1.6000, 0.2000}};
    float corr_answer[30] = {1, 0, 2, 1, 1, 0, 1, 2, 1, 1, 2, 0, 0, 0, 0, 1, 2, 1, 1, 2, 0, 2, 0, 2,
        2, 2, 2, 2, 0, 0};
    
    double train_data[120][4] {{4.6000, 3.6000, 1.0000, 0.2000},
        {5.7000, 4.4000, 1.5000, 0.4000},
        {6.7000, 3.1000, 4.4000, 1.4000},
        {4.8000, 3.4000, 1.6000, 0.2000},
        {4.4000, 3.2000, 1.3000, 0.2000},
        {6.3000, 2.5000, 5.0000, 1.9000},
        {6.4000, 3.2000, 4.5000, 1.5000},
        {5.2000, 3.5000, 1.5000, 0.2000},
        {5.0000, 3.6000, 1.4000, 0.2000},
        {5.2000, 4.1000, 1.5000, 0.1000},
        {5.8000, 2.7000, 5.1000, 1.9000},
        {6.0000, 3.4000, 4.5000, 1.6000},
        {6.7000, 3.1000, 4.7000, 1.5000},
        {5.4000, 3.9000, 1.3000, 0.4000},
        {5.4000, 3.7000, 1.5000, 0.2000},
        {5.5000, 2.4000, 3.7000, 1.0000},
        {6.3000, 2.8000, 5.1000, 1.5000},
        {6.4000, 3.1000, 5.5000, 1.8000},
        {6.6000, 3.0000, 4.4000, 1.4000},
        {7.2000, 3.6000, 6.1000, 2.5000},
        {5.7000, 2.9000, 4.2000, 1.3000},
        {7.6000, 3.0000, 6.6000, 2.1000},
        {5.6000, 3.0000, 4.5000, 1.5000},
        {5.1000, 3.5000, 1.4000, 0.2000},
        {7.7000, 2.8000, 6.7000, 2.0000},
        {5.8000, 2.7000, 4.1000, 1.0000},
        {5.2000, 3.4000, 1.4000, 0.2000},
        {5.0000, 3.5000, 1.3000, 0.3000},
        {5.1000, 3.8000, 1.9000, 0.4000},
        {5.0000, 2.0000, 3.5000, 1.0000},
        {6.3000, 2.7000, 4.9000, 1.8000},
        {4.8000, 3.4000, 1.9000, 0.2000},
        {5.0000, 3.0000, 1.6000, 0.2000},
        {5.1000, 3.3000, 1.7000, 0.5000},
        {5.6000, 2.7000, 4.2000, 1.3000},
        {5.1000, 3.4000, 1.5000, 0.2000},
        {5.7000, 3.0000, 4.2000, 1.2000},
        {7.7000, 3.8000, 6.7000, 2.2000},
        {4.6000, 3.2000, 1.4000, 0.2000},
        {6.2000, 2.9000, 4.3000, 1.3000},
        {5.7000, 2.5000, 5.0000, 2.0000},
        {5.5000, 4.2000, 1.4000, 0.2000},
        {6.0000, 3.0000, 4.8000, 1.8000},
        {5.8000, 2.7000, 5.1000, 1.9000},
        {6.0000, 2.2000, 4.0000, 1.0000},
        {5.4000, 3.0000, 4.5000, 1.5000},
        {6.2000, 3.4000, 5.4000, 2.3000},
        {5.5000, 2.3000, 4.0000, 1.3000},
        {5.4000, 3.9000, 1.7000, 0.4000},
        {5.0000, 2.3000, 3.3000, 1.0000},
        {6.4000, 2.7000, 5.3000, 1.9000},
        {5.0000, 3.3000, 1.4000, 0.2000},
        {5.0000, 3.2000, 1.2000, 0.2000},
        {5.5000, 2.4000, 3.8000, 1.1000},
        {6.7000, 3.0000, 5.0000, 1.7000},
        {4.9000, 3.1000, 1.5000, 0.2000},
        {5.8000, 2.8000, 5.1000, 2.4000},
        {5.0000, 3.4000, 1.5000, 0.2000},
        {5.0000, 3.5000, 1.6000, 0.6000},
        {5.9000, 3.2000, 4.8000, 1.8000},
        {5.1000, 2.5000, 3.0000, 1.1000},
        {6.9000, 3.2000, 5.7000, 2.3000},
        {6.0000, 2.7000, 5.1000, 1.6000},
        {6.1000, 2.6000, 5.6000, 1.4000},
        {7.7000, 3.0000, 6.1000, 2.3000},
        {5.5000, 2.5000, 4.0000, 1.3000},
        {4.4000, 2.9000, 1.4000, 0.2000},
        {4.3000, 3.0000, 1.1000, 0.1000},
        {6.0000, 2.2000, 5.0000, 1.5000},
        {7.2000, 3.2000, 6.0000, 1.8000},
        {4.6000, 3.1000, 1.5000, 0.2000},
        {5.1000, 3.5000, 1.4000, 0.3000},
        {4.4000, 3.0000, 1.3000, 0.2000},
        {6.3000, 2.5000, 4.9000, 1.5000},
        {6.3000, 3.4000, 5.6000, 2.4000},
        {4.6000, 3.4000, 1.4000, 0.3000},
        {6.8000, 3.0000, 5.5000, 2.1000},
        {6.3000, 3.3000, 6.0000, 2.5000},
        {4.7000, 3.2000, 1.3000, 0.2000},
        {6.1000, 2.9000, 4.7000, 1.4000},
        {6.5000, 2.8000, 4.6000, 1.5000},
        {6.2000, 2.8000, 4.8000, 1.8000},
        {7.0000, 3.2000, 4.7000, 1.4000},
        {6.4000, 3.2000, 5.3000, 2.3000},
        {5.1000, 3.8000, 1.6000, 0.2000},
        {6.9000, 3.1000, 5.4000, 2.1000},
        {5.9000, 3.0000, 4.2000, 1.5000},
        {6.5000, 3.0000, 5.2000, 2.0000},
        {5.7000, 2.6000, 3.5000, 1.0000},
        {5.2000, 2.7000, 3.9000, 1.4000},
        {6.1000, 3.0000, 4.6000, 1.4000},
        {4.5000, 2.3000, 1.3000, 0.3000},
        {6.6000, 2.9000, 4.6000, 1.3000},
        {5.5000, 2.6000, 4.4000, 1.2000},
        {5.3000, 3.7000, 1.5000, 0.2000},
        {5.6000, 3.0000, 4.1000, 1.3000},
        {7.3000, 2.9000, 6.3000, 1.8000},
        {6.7000, 3.3000, 5.7000, 2.1000},
        {5.1000, 3.7000, 1.5000, 0.4000},
        {4.9000, 2.4000, 3.3000, 1.0000},
        {6.7000, 3.3000, 5.7000, 2.5000},
        {7.2000, 3.0000, 5.8000, 1.6000},
        {4.9000, 3.6000, 1.4000, 0.1000},
        {6.7000, 3.1000, 5.6000, 2.4000},
        {4.9000, 3.0000, 1.4000, 0.2000},
        {6.9000, 3.1000, 4.9000, 1.5000},
        {7.4000, 2.8000, 6.1000, 1.9000},
        {6.3000, 2.9000, 5.6000, 1.8000},
        {5.7000, 2.8000, 4.1000, 1.3000},
        {6.5000, 3.0000, 5.5000, 1.8000},
        {6.3000, 2.3000, 4.4000, 1.3000},
        {6.4000, 2.9000, 4.3000, 1.3000},
        {5.6000, 2.8000, 4.9000, 2.0000},
        {5.9000, 3.0000, 5.1000, 1.8000},
        {5.4000, 3.4000, 1.7000, 0.2000},
        {6.1000, 2.8000, 4.0000, 1.3000},
        {4.9000, 2.5000, 4.5000, 1.7000},
        {5.8000, 4.0000, 1.2000, 0.2000},
        {5.8000, 2.6000, 4.0000, 1.2000},
        {7.1000, 3.0000, 5.9000, 2.1000}};

    int train_label[120] = {0 ,0, 1, 0, 0, 2, 1, 0, 0, 0, 2, 1, 1, 0, 0, 1, 2, 2, 1, 2, 1, 2, 1, 0, 2, 1, 0, 0, 0, 1, 2, 0, 0, 0, 1, 0, 1,
        2, 0, 1, 2, 0, 2, 2, 1, 1, 2, 1, 0, 1, 2, 0, 0, 1, 1, 0, 2, 0, 0, 1, 1, 2, 1, 2, 2, 1, 0, 0, 2, 2, 0, 0, 0, 1,
        2, 0, 2, 2, 0, 1, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 1, 0, 1, 1, 0, 1, 2, 2, 0, 1, 2, 2, 0, 2, 0, 1, 2, 2, 1, 2, 1,
        1, 2, 2, 0, 1, 2, 0, 1, 2};
  
    bool* aa;
    bool* bb;
    bool* cc;
    double summention = 0;
    // for(int i = 0;i < 10000; i++){
    //     double r1 = (double)rand() / (RAND_MAX + 1.0);
    //     aa = sc.bit_gen(2.0*r1-1.0);
    //     double r2 = (double)rand() / (RAND_MAX + 1.0);
    //     bb = sc.bit_gen(2.0*r2-1.0);
    //     cc = sc.MUX(aa,bb);
    //     summention += abs(sc.print(cc) - (r1 + r2) / 2.0);
    // }
    // cout<<"error = "<<summention/10000.0<<endl;

    bool* layer_0[4];
    for(size_t i=0; i<4; i++){
        layer_0[i] = sc.bit_gen(0);
    } 

    bool* layer_1[15];
    for(size_t i=0; i<5; i++){
        layer_1[i] = sc.bit_gen(0);
    } 

    bool* layer_2[3];
    for(size_t i=0; i<5; i++){
        layer_2[i] = sc.bit_gen(0);
    } 

    double _layer_0[4];
    double _layer_1[15];
    double _layer_2[3];

    double store_layer_1[30][10];

    float corr_count = 0;
    float max = 0, max_cand = 0;
    double temp = 0;

    //--------------divide the data by 10.0---------------
    for(unsigned i =0; i < 30; i++){
        for(unsigned j = 0; j < 4; j++){
            x_test[i][j] /= 10.0;
        }
    }

    // // divide the weights and bias by 10.0
    for(unsigned i =0; i < 15; i++){
        for(unsigned j = 0; j < 4; j++){
            weight_1[i][j] /= 10.0;
        }
    }

    for(unsigned i =0; i < 15; i++){
        bias_1[i] /= 10.0;
    }

    // for(unsigned i =0; i < 3; i++){
    //     for(unsigned j = 0; j < 5; j++){
    //         weight_2[i][j] /= 10.0;
    //     }
    // }

    for(unsigned i =0; i < 3; i++){
        bias_2[i] /= 10.0;
    }

    //
    corr_count = 0;
    for(int k=0; k<30; k++){
        for(int i=0;i<4;i++){
            _layer_0[i] = x_test[k][i];
        }
        for(int i=0;i<15;i++){
            _layer_1[i] = 0;
        }
        for(int i=0;i<3;i++){
            _layer_2[i] = 0;
                  }


        for(int i=0;i<15;i++){
            for(int j=0;j<4;j++){
                _layer_1[i] += _layer_0[j] * weight_1[i][j];
            }
            // _layer_1[i] /= 4.0;
            store_layer_1[k][i]=_layer_1[i];
            _layer_1[i] += bias_1[i];
            // _layer_1[i] /= 4.0;
            // _layer_1[i] /= 2.0;
        }
    
        for(int i=0;i<3;i++){
            for(int j=0;j<15;j++){
                _layer_2[i] += _layer_1[j] * weight_2[i][j];
            }
            // _layer_2[i] /= 5.0;
            _layer_2[i] += bias_2[i];
            // _layer_2[i] /= 5.0;
            // _layer_2[i] /= 2.0;
        }
        
        
        
        max = -10000;
        max_cand = 0;

        for(size_t j=0; j<3;j++){
            if(_layer_2[j] > max){
                max = _layer_2[j];
                max_cand = j;
            }
            // cout << "layer 2[" << j << "] is :" << _layer_2[j] <<endl;
            // cout << "max cand is : " << max_cand << endl;
        }
        // cout<<max_cand<<endl;

        if(max_cand == corr_answer[k]){
            corr_count += 1;
            // cout<<"correct!!!!!("<<corr_count<<'/'<<k+1<<')'<<endl;
        }
        else{
            // cout<<"wrong!!!!!("<<corr_count<<'/'<<k+1<<')'<<endl;
        }

    }
    cout<<"The rate of correctness is: "<<corr_count/30.0<<endl;
    
    //----------------------------------------------------------------------------------
    corr_count = 0;

    for(int k=0; k<30; k++){
        for(int i=0;i<4;i++){
            layer_0[i] = sc.bit_gen(x_test[k][i]);
        }
            
        for(int i=0;i<15;i++){
            layer_1[i] = sc.bit_gen(0);
        }

        for(int i=0;i<3;i++){
            layer_2[i] = sc.bit_gen(0);
        }


        for(int i=0;i<15;i++){
            // for(int j=0;j<4;j++){
            //     layer_1[i] = sc.APC(layer_1[i] ,sc.XNOR(layer_0[j],sc.bit_gen(weight_1[i][j])));
            // }
            layer_1[i] = sc.MUX_4(sc.XNOR(layer_0[0],sc.bit_gen(weight_1[i][0])),sc.XNOR(layer_0[1],sc.bit_gen(weight_1[i][1])),sc.XNOR(layer_0[2],sc.bit_gen(weight_1[i][2])),sc.XNOR(layer_0[3],sc.bit_gen(weight_1[i][3])));
            // cout<<(store_layer_1[k][i]-sc.print(layer_1[i]))<<endl;
            // cout << store_layer_1[k][i] << endl;
            layer_1[i] = sc.MUX(layer_1[i],sc.bit_gen(bias_1[i]));
        }
    
        for(int i=0;i<3;i++){
            // for(int j=0;j<5;j++){
            //      layer_2[i] = sc.APC(layer_2[i] ,sc.XNOR(layer_1[j],sc.bit_gen(weight_2[i][j])));
            // }
            layer_2[i] = sc.MUX_15(sc.XNOR(layer_1[0],sc.bit_gen(weight_2[i][0])),sc.XNOR(layer_1[1],sc.bit_gen(weight_2[i][1])),sc.XNOR(layer_1[2],sc.bit_gen(weight_2[i][2])),sc.XNOR(layer_1[3],sc.bit_gen(weight_2[i][3])),sc.XNOR(layer_1[4],sc.bit_gen(weight_2[i][4])),sc.XNOR(layer_1[5],sc.bit_gen(weight_2[i][5])),sc.XNOR(layer_1[6],sc.bit_gen(weight_2[i][6])),sc.XNOR(layer_1[7],sc.bit_gen(weight_2[i][7])),sc.XNOR(layer_1[8],sc.bit_gen(weight_2[i][8])),sc.XNOR(layer_1[9],sc.bit_gen(weight_2[i][9])),sc.XNOR(layer_1[10],sc.bit_gen(weight_2[i][10])),sc.XNOR(layer_1[11],sc.bit_gen(weight_2[i][11])),sc.XNOR(layer_1[12],sc.bit_gen(weight_2[i][12])),sc.XNOR(layer_1[13],sc.bit_gen(weight_2[i][13])),sc.XNOR(layer_1[14],sc.bit_gen(weight_2[i][14])));  
            layer_2[i] = sc.MUX(layer_2[i],sc.bit_gen(bias_2[i]));
            
        }
        
        
        max = -10000;
        max_cand = 0;

        for(size_t j=0; j<3;j++){
            if(sc.print(layer_2[j]) > max){
                max = sc.print(layer_2[j]);
                max_cand = j;
            }
            // cout << "layer 2[" << j << "] is :" << sc.print(layer_2[j]) <<endl;
            // cout << "max cand is : " << max_cand << endl;
        }
        // cout<<max_cand<<endl;

        if(max_cand == corr_answer[k]){
            corr_count += 1;
            // cout<<"correct!!!!!("<<corr_count<<'/'<<k+1<<')'<<endl;
        }
        else{
            // cout<<"wrong!!!!!("<<corr_count<<'/'<<k+1<<')'<<endl;
        }

    }
    cout<<"The rate of correctness is: "<<corr_count/30.0<<endl;
    
    return 0;
}


// bool* aa;
//     bool* bb;
//     bool* cc;
//     double summention = 0;
//     for(int i = 0;i < 10000; i++){
//         double r1 = (double)rand() / (RAND_MAX + 1.0);
//         aa = sc.bit_gen(2.0*r1-1.0);
//         double r2 = (double)rand() / (RAND_MAX + 1.0);
//         bb = sc.bit_gen(2.0*r2-1.0);
//         cc = sc.MUX(aa,bb);
//         summention += abs(sc.print(cc) - (r1 + r2) / 2.0);
//     }
//     cout<<"error = "<<summention/10000.0<<endl;

//     ESL layer_0[4];
//     for(size_t i=0; i<4; i++){
//         layer_0[i] = sc.number_gen(0);
//     } 

//     ESL layer_1[10];
//     for(size_t i=0; i<10; i++){
//         layer_1[i] = sc.number_gen(0);
//     } 

//     ESL layer_2[3];
//     for(size_t i=0; i<5; i++){
//         layer_2[i] = sc.number_gen(0);
//     } 

//     double _layer_0[4];
//     double _layer_1[10];
//     double _layer_2[3];

//     double store_layer_1[30][10];

//     float corr_count = 0;
//     float max = 0, max_cand = 0;
//     double temp = 0;

//     //-----------------------------
//     corr_count = 0;
//     for(int k=0; k<30; k++){
//         for(int i=0;i<4;i++){
//             _layer_0[i] = x_test[k][i];
//         }
//         for(int i=0;i<5;i++){
//             _layer_1[i] = 0;
//         }
//         for(int i=0;i<3;i++){
//             _layer_2[i] = 0;
//                   }


//         for(int i=0;i<5;i++){
//             for(int j=0;j<4;j++){
//                 _layer_1[i] += _layer_0[j] * weight_1[i][j];
//             }
//             store_layer_1[k][i]=_layer_1[i];
//             _layer_1[i] += bias_1[i];
//         }
    
//         for(int i=0;i<3;i++){
//             for(int j=0;j<5;j++){
//                 _layer_2[i] += _layer_1[j] * weight_2[i][j];
//             }
//             _layer_2[i] += bias_2[i];
//         }
        
        
        
//         max = -10000;
//         max_cand = 0;

//         for(size_t j=0; j<3;j++){
//             if(_layer_2[j] > max){
//                 max = _layer_2[j];
//                 max_cand = j;
//             }
//             // cout << "layer 2[" << j << "] is :" << _layer_2[j] <<endl;
//             // cout << "max cand is : " << max_cand << endl;
//         }
//         // cout<<max_cand<<endl;

//         if(max_cand == corr_answer[k]){
//             corr_count += 1;
//             // cout<<"correct!!!!!("<<corr_count<<'/'<<k+1<<')'<<endl;
//         }
//         else{
//             // cout<<"wrong!!!!!("<<corr_count<<'/'<<k+1<<')'<<endl;
//         }

//     }
//     cout<<"The rate of correctness is: "<<corr_count/30.0<<endl;
    
//     //----------------------------------------------------------------------------------
//     corr_count = 0;

//     for(int k=0; k<30; k++){
//         for(int i=0;i<4;i++){
//             layer_0[i] = sc.number_gen(x_test[k][i]);
//         }
            
//         for(int i=0;i<5;i++){
//             layer_1[i] = sc.number_gen(0);
//         }

//         for(int i=0;i<3;i++){
//             layer_2[i] = sc.number_gen(0);
//         }


//         for(int i=0;i<5;i++){
//             // for(int j=0;j<4;j++){
//             //     layer_1[i] = sc.NEW_APC(layer_1[i] ,sc.XNOR(layer_0[j],sc.number_gen(weight_1[i][j])));
//             // }
//             layer_1[i] = sc.ESL_Adder_4(sc.XNOR(layer_0[0],sc.number_gen(weight_1[i][0])),sc.XNOR(layer_0[1],sc.number_gen(weight_1[i][1])),sc.XNOR(layer_0[2],sc.number_gen(weight_1[i][2])),sc.XNOR(layer_0[3],sc.number_gen(weight_1[i][3])));
//             // cout<<abs((store_layer_1[k][i]-sc.print(layer_2[i])))<<endl;
//             layer_1[i] = sc.ESL_Adder(layer_1[i],sc.number_gen(bias_1[i]));
//         }
    
//         for(int i=0;i<3;i++){
//             for(int j=0;j<5;j++){
//                 layer_2[i] = sc.ESL_Adder_5(sc.XNOR(layer_1[0],sc.number_gen(weight_2[i][0])),sc.XNOR(layer_1[1],sc.number_gen(weight_2[i][1])),sc.XNOR(layer_1[2],sc.number_gen(weight_2[i][2])),sc.XNOR(layer_1[3],sc.number_gen(weight_2[i][3])),sc.XNOR(layer_1[4],sc.number_gen(weight_2[i][4])));
                
//             }
//             layer_2[i] = sc.ESL_Adder(layer_2[i],sc.number_gen(bias_2[i]));
            
//         }
        
        
//         max = -10000;
//         max_cand = 0;

//         for(size_t j=0; j<3;j++){
//             if(sc.print(layer_2[j]) > max){
//                 max = sc.print(layer_2[j]);
//                 max_cand = j;
//             }
//             // cout << "layer 2[" << j << "] is :" << sc.print(layer_2[j]) <<endl;
//             // cout << "max cand is : " << max_cand << endl;
//         }
//         // cout<<max_cand<<endl;

//         if(max_cand == corr_answer[k]){
//             corr_count += 1;
//             // cout<<"correct!!!!!("<<corr_count<<'/'<<k+1<<')'<<endl;
//         }
//         else{
//             // cout<<"wrong!!!!!("<<corr_count<<'/'<<k+1<<')'<<endl;
//         }

//     }
//     cout<<"The rate of correctness is: "<<corr_count/30.0<<endl;
    
//     return 0;
// }